# 									Java SE

## 1 数据类型

​					分为基本数据类型：整数(byte, short, int, long)，

​													  浮点数(float, double)，

​                                                      字符(char)，

​													   布尔(boolean)。

​						    引用数据类型：类，

​											           接口，

​                                                       数组。

### 1.1 基本数据类型

​						以下为整数型

| 类型英文 | 占用空间(字节数) |     取值范围     |
| :------: | :--------------: | :--------------: |
|   byte   |        1         |  -2^7  ~  2^7-1  |
|  short   |        2         | -2^15  ~  2^15-1 |
|   int    |        4         | -2^31  ~  2^31-1 |
|   long   |        8         | -2^63  ~  2^63-1 |

​					以下为浮点型

| 类型英文 | 占用空间(字节数) |        取值范围        |
| :------: | :--------------: | :--------------------: |
|  float   |        4         | -3.403E38  ~  3.403E38 |
|  double  |        8         | -1.798E308 ~ 1.798E308 |

​					以下为字符型

| 类型英文 | 占用空间(字节数) |            取值范围             |
| :------: | :--------------: | :-----------------------------: |
|   char   |        2         | 表示一个字符，如('a', 'A','家') |

​					以下为布尔型

| 类型英文 | 占用空间(字节数) |     取值范围      |
| :------: | :--------------: | :---------------: |
| boolean  |        1         | true   /    false |



<u>注意！！！：</u>

​				<u>整数默认为 int;</u>

​				<u>浮点数默认为 double;</u>

​				<u>定义long类型的数据时，要加L或l,建议加L;</u>

​				<u>定义float类型的数据时，要加F或f,建议加F；</u>

​				<u>变量声明后未赋值，则不能使用；</u>

​				<u>变量只属于它所在的大括号；</u>



### 1.2 类型转换

#### 1.2.1 隐式转换

​				几个类型不同的变量混合运算时，往大的转，如下所示：

​				byte,short,char --->	int --->	long --->	float --->	double

#### 1.2.2 强制转换

​				用法：目标类型	变量名 =  (目标类型)	(被转换的数据);





//嗯，中间略过了很多





## 2 常用API



## 3 static

​				static: 是一个关键字，用于修饰成员变量和成员方法。

​				特点：(1)被所有对象所共享;

​							(2)可以被类名调用;

​							(3)静态的加载优先于对象，随着类的加载而加载;

​				static注意事项: 

​							静态可以调用静态；非静态可以调用静态；静态不能调用非静态;

​							静态方法中没有this ！！！



​				static优点: 对对象的共享数据提供单独空间的存储，节省空间，没必要每个对象都存储一份;可以直接被类名调用，不用再堆内存创建对象;

​				static缺点: 访问局限性(静态智能访问静态);

## 4.代码块

### 4.1局部代码块

​				存在于代码中，用来控制变量的生命周期(作用域);

### 4.2构造代码块

​				存在于类中，提取构造方法中的共性，每次创建对象都会执行，并且先于构造方法执行.

### 4.3静态代码块

​				比构造代码块前面多个了static.

​				由于是静态，所以随着类的加载而加载(只加载一次，和多少个对象没有关系)。

​				用途: 比如加载类时要做初始化，比如加载驱动。

### 4.4代码块面试题

​				代码块加载顺序: (1)首先是静态代码块，随着类的加载而执行，只执行一次，和对象的数量没关系;

​											 (2)然后如果new 对象了，就后悔执行构造代码块，每new一个对象就执行一次;

​											 (3)然后执行new 对象的无参或带参构造;



## 5.继承和抽象类

### 5.1 继承的概述

​					多个类有共同的成员变量和成员方法，抽取到另外一个类（父类）中，再让多个类去继承这个父类，这多个类就可以获取到父类中的成员了。

### 5.2 继承的特点

​					- java只支持单继承，只能继承一个父类；

​					- java支持多层继承；

### 5.3 继承中成员变量的特点

​					- 子类只能获取父类非私有成员；

 				   - 成员变量采用就近原则，如果子类中有，就用子类的，如果子类中没有，那就使用父类的。 

​					- 关键字super:父类的引用(用法类似于this)，可以获取父类的成员变量和成员方法。

### 5.4 继承中成员方法特点

​				- 方法的重写：再同一个类中，方法名相同，参数列表不同，与返回值无关。

​				- 方法的重写: 在子父类中，子类的方法和父类的方法完全一样。当子类重写父类方法后，子类对象调用的就是子类重写后的方法。

​				-如果子类中没有这个方法，就调用父类的。

​				- 如果子类重写了这个方法，那就调用子类重写后的方法；

### 5.5 方法重写的应用场景和注意事项

​				应用场景：当父类方法不能满足子类使用时，子类重写父类方法，并且可以在子类方法中使用super关键字来调用父类方法。

​				注意事项：- 不能重写父类私有的方法；

​								   - 子类重写后的方法的权限必须大于等于父类方法的权限；

### 5.6 继承中构造方法的执行顺序

​				有子父类继承关系的类，创建子类对象，调用子类的构造方法，如果子类构造方法的第一行代码没有调用父类的构造方法，则会默认调用父类的无参构造。

​				我们可以在子类的构造方法中使用 super(...) 来调用父类中的构造方法；

​				肯定会执行父类的构造(无参或有参)，因为先要给父类的成员变量初始化；

### 5.7 this和super的区别

​				this：当前对象的引用；

​				super：子类对象的父类引用；

### 5.8 继承的优缺点

​				优点：- 提高了代码的复用性；

​							- 提高了代码的可维护性；

​				缺点：- 类的耦合性变大了；

### 5.9 抽象类的概述

​				关键字abstract: 用于修饰方法和类。

​			   抽象方法：不同类的方法都相似，但是具体内容又不同，所以我们抽取方法的声明，而没有具体的方法体。这就是抽象方法，

​				抽象类：有抽象方法的类必须是抽象类。

​				注意：一个非抽象类继承了一个抽象类，就必须重写这个抽象类里的所有抽象方法，抽象类里可以有非抽象方法，继承抽象类后，可以不重写抽象类里的非抽象方法。

​				抽象类可以继承抽象类，子抽象类可以不重写父抽象类中的抽象方法；

### 5.10 抽象类的特点

​				- 抽象方法只能在抽象类里面；

​				- 抽象方法和抽象类必须用abstact修饰；

​				- 抽象类不能创建对象(不能实例化)；

​				- 抽象类中可以有非抽象方法；

				- 一个类继承了抽象类，那么它要么重写父抽象类中的所有抽象方法，要么它自己本身也是抽象类；

### 5.11抽象类的成员特点

​				-成员变量:

​						可以有成员变量；

​						可以有常量；

​				-成员方法：

​						可以又抽象方法或非抽象方法；

​				-构造方法：

​						可以有构造方法，对抽象类的成员变量进行初始化；

### 5.12抽象类的细节

​		

## 6.接口与多态

### 6.1接口

#### 6.11什么是接口

​				由于java是单继承的，为了处理单一继承的局限性，java提供了接口；

​				接口是一个比抽象类还抽象的类，接口里所有的方法都是抽象方法，关键字interface；

​				接口和类的关系是实现（关键字implements）；

#### 6.12接口的成员特点

​				只能有常量；

​				接口里的成员变量默认使用public static final修饰；

​				只能有抽象方法；

​				接口不能创建对象(不能实例化)；

​				一个类实现接口，必须实现接口的所有方法；

​				接口里的方法默认使用private abstract 修饰，并且只能用private abstract 修饰；

#### 6.13类与接口之间的关系

​				一个类可以实现多个接口；

​				一个接口可以继承多个接口，也可以多层继承；

#### 6.14 接口的优点

​				-打破了java中单一继承的局限性;

​				-对外提供规则；

​				-降低了程序的耦合性 （可以实现模块化开发，定好规则，每个人实现自己的模块，提高了开发效率）；

#### 6.15接口和抽象类的区别

​				共性：不断地抽取，抽取出抽象的概念；

​				区别1：一个类可以实现多个接口；一个类只能继承一个抽象类；

​				区别2：

​					

|          |               抽象类               |                       接口                        |
| -------- | :--------------------------------: | :-----------------------------------------------: |
| 成员变量 |    可以有成员变量，也可以有常量    |                    只能有常量                     |
| 成员方法 | 可以有抽象方法，也可以有非抽象方法 | 只能有抽象方法，且方法有默认修饰符public abstract |
| 构造方法 |             有构造方法             |                   没有构造方法                    |

#### 6.16 final

​				final所修饰的类：不能被继承；

​				final所修饰的方法：不能被重写；

​				final所修饰的变量：不能被修改，是常量；



​				常量：

​							-字面值常量：1，2，3；

​							-自定义常量；

​						注意：自定义常量必须初始化，显示初始化或构造初始化；

### 6.2多态

#### 6.21多态的前提

​				-子父类继承关系(或者实现接口)；

​				-方法的重写；

​				-父类引用指向子类对象；

#### 6.21多态的成员特点

|          | 编译时 | 运行时 |
| :------: | :----: | :----: |
| 成员变量 | 看左边 | 看左边 |
| 成员方法 | 看左边 | 看右边 |
| 静态方法 | 看左边 | 看左边 |

#### 6.22多态向上和向下转型

​				向上转型：由小辈转成长辈；（多态本身就是向上转型）

​				向下转型：由长辈转成小辈；(本身是什么类型就转回成什么类型，不能转成其他类型)

#### 6.23多态优缺点

​				缺点：无法访问子类特有的成员(比如子类中有的成员在父类中没有,就没法访问调用)。

​				