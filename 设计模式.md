# 1.原则

## 1.1原则介绍

```

```

## 1.2.单一职责原则

```
例子引入：一个类A负责两个不同的职责T1和T2,当职责T1的需求改动需要修改时，可能会影响到T2。
下面通过三个案例来描述:
```

```java
public class Demo1 {
	public static void main(String[] args) {
		Vehicle vehicle = new Vehicle();
		vehicle.run("汽车");
		vehicle.run("摩托车");
		vehicle.run("飞机");
	}
}

//交通工具类
//违反了单一职责原则，飞机不能再公路上跑
class Vehicle{
	public void run(String vehicle) {
		System.out.println(vehicle+"    在公路上跑");
	}
}
```

```java
public class Demo2 {
	public static void main(String[] args) {
		new RoadVehicle().run("摩托车");
		new AirVehicle().run("波音747");
		new WaterVehicle().run("航母");
	}
}

//遵守了单一职责原则，但是改动较大，类太多

//路上跑的交通工具
class RoadVehicle{
	public void run(String vehicle) {
		System.out.println(vehicle+"    在公路上跑");
	}
}

//空中交通工具
class AirVehicle{
	public void run(String vehicle) {
		System.out.println(vehicle+"    在天上飞");
	}
}

//水中交通工具
class WaterVehicle{
	public void run(String vehicle) {
		System.out.println(vehicle+"    在水上运行");
	}
}
```

```java
public class Demo3 {
	public static void main(String[] args) {
		Vehicle2 vehicle2 = new Vehicle2();
		vehicle2.run("汽车");
		vehicle2.fly("飞艇");
		vehicle2.swim("帆船");
	}
}

//没有增加新的类，只是对原来的类修改;
//这次虽然没有在类级别上遵单一职责原则,但是在方法级别上遵守亿职责原则
class Vehicle2{
	public void run(String vehicle) {
		System.out.println(vehicle+"    在公路上跑");
	}
	public void fly(String vehicle) {
		System.out.println(vehicle+"    在空中飞");
	}
	public void swim(String vehicle) {
		System.out.println(vehicle+"    在水上运行");
	}
}
```

```
单一职责原则注意事项和细节：
1)降低类的复杂度，一个类只能负责一个职责。
2)提高类的可读性，可维护性。
3)降低变更引起的风险。
4)通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级别违反单一职责原则;只有类种方法足够少，可以在方法级别保持单一职责原则。
```



## 1.3.接口隔离原则

```
简介：客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。

案例：假设 接口Interface1种有5个方法,
         类B实现接口Interface1,
         类D实现接口Interface1,
         类A通过接口Interface1依赖(使用)到类B，但是A只用Interface中的1,2,3这三个方法，
         类C通过接口Interface1依赖(使用)到类B，但是A只用Interface中的1,4,5这三个方法，
     如下图所示:
```

![原则_接口隔离原则1](设计模式_pic/原则_接口隔离原则1.jpg)

```
代码如下所示：
```

```java
interface Interface1{
	void operation1();
	void operation2();
	void operation3();
	void operation4();
	void operation5();
}

class B implements Interface1{
	@Override
	public void operation1() {
		System.out.println("B    实现了    opreation1");
	}
	@Override
	public void operation2() {
		System.out.println("B    实现了    opreation2");
	}
	@Override
	public void operation3() {
		System.out.println("B    实现了    opreation3");
	}
	@Override
	public void operation4() {
		System.out.println("B    实现了    opreation4");
	}
	@Override
	public void operation5() {
		System.out.println("B    实现了    opreation5");
	}
}

class D implements Interface1{
	@Override
	public void operation1() {
		System.out.println("D    实现了    opreation1");
	}
	@Override
	public void operation2() {
		System.out.println("D    实现了    opreation2");
	}
	@Override
	public void operation3() {
		System.out.println("D    实现了    opreation3");
	}
	@Override
	public void operation4() {
		System.out.println("D    实现了    opreation4");
	}
	@Override
	public void operation5() {
		System.out.println("D    实现了    opreation5");
	}
}

class A { //A类通过接口Interface1 依赖(使用) B类,但是只用到1,2,3方法
	public void depend1zui(Interface1 i) {
		i.operation1();
	}
	public void depend2(Interface1 i) {
		i.operation2();
	}
	public void depend3(Interface1 i) {
		i.operation3();
	}
}

class C { //C类通过接口Interface1 依赖(使用) D类,但是只用到1,4,5方法
	public void depend1zui(Interface1 i) {
		i.operation1();
	}
	public void depend4(Interface1 i) {
		i.operation4();
	}
	public void depend5(Interface1 i) {
		i.operation5();
	}
}
```

```
将接口Interface1拆分成独立的几个接口，类A和类C分别与它们需要的接口建立依赖关系，也就是采用接口隔离原则。
接口Interface1中出现的方法，根据实际情况拆分成三个接口.如下图所示：
```

![原则_接口隔离原则2](设计模式_pic/原则_接口隔离原则2.jpg)

```
改造后代码如下所示：
```

```java
public class Demo1 {
	public static void main(String[] args) {
		A a = new A();
		a.depend1(new B());//这就是A类通过接口去依赖B类
		a.depend2(new B());
		a.depend3(new B());
		C c = new C();
		c.depend1(new D());
		c.depend4(new D());
		c.depend5(new D());
	}
}

interface Interface1{
	void operation1();
}
interface Interface2{
	void operation2();
	void operation3();
}
interface Interface3{
	void operation4();
	void operation5();
}

class B implements Interface1,Interface2{
	@Override
	public void operation1() {
		System.out.println("B    实现了    opreation1");
	}
	@Override
	public void operation2() {
		System.out.println("B    实现了    opreation2");
	}
	@Override
	public void operation3() {
		System.out.println("B    实现了    opreation3");
	}
}

class D implements Interface1,Interface3{
	@Override
	public void operation1() {
		System.out.println("D    实现了    opreation1");
	}
	@Override
	public void operation4() {
		System.out.println("D    实现了    opreation4");
	}
	@Override
	public void operation5() {
		System.out.println("D    实现了    opreation5");
	}
}

class A { //A类通过接口Interface1和Interface2 依赖(使用) B类,但是只用到1,2,3方法
	public void depend1(Interface1 i) {
		i.operation1();
	}
	public void depend2(Interface2 i) {
		i.operation2();
	}
	public void depend3(Interface2 i) {
		i.operation3();
	}
}

class C { //C类通过接口Interface1和Interface3 依赖(使用) D类,但是只用到1,4,5方法
	public void depend1(Interface1 i) {
		i.operation1();
	}
	public void depend4(Interface3 i) {
		i.operation4();
	}
	public void depend5(Interface3 i) {
		i.operation5();
	}
}
```



## 1.4.依赖倒转原则

```
依赖倒转原则指的是：
1)高层模块不应依赖于低层模块，二者都应依赖于其抽象。
2)抽象不应该依赖细节，细节应该依赖抽象。
3)依赖倒转的中心思想是面向接口编程。
4)依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定得多。以抽象为基础搭建的架构要比以细节为基础的架构要稳定得多。在java中，抽象指的是接口或抽象类，细节就是具体得实现类。
5)使用接口或抽象类得目的是制定好规范，而不涉及任何具体操作，把展现细节的任务交给它们的实现类去完成。
```

```
先看下面一个案例:
```

```java
public class Demo1 {
	public static void main(String[] args) {
		Person person = new Person();
		person.receive(new Email());
	}
}

//完成Person接收消息的功能
//方式1完成
//缺点：方法里写死了指定Email类，如果我们不接收Email,而是微信呢？
class Person{
	public void receive(Email e) {
		System.out.println(e.getInfo());
	}
}

class Email{
	public String getInfo() {
		return "电子邮件内容：Hello World";
	}
}
```

```
解决思路：
	引入一个IReceiver接口，表示接收的工具，这样Person就与接口发生依赖。
	这样，无论是那种通讯工具，只要实现IReceiver接口即可,这样就符合依赖倒转原则了。
改进方案：
```

```java
public class Demo1 {
	public static void main(String[] args) {
		Person person = new Person();
		person.receive(new Email());
		person.receive(new Weixin());
		person.receive(new QQ());
	}
}

//完成Person接收消息的功能
class Person{
	public void receive(IReceiver i) {
		System.out.println(i.getInfo());
	}
}

interface IReceiver{
	public String getInfo();
}
/////////////////////////////////////////////////////////////////////////////////
class Email implements IReceiver{
	@Override
	public String getInfo() {
		return "电子邮件内容：Hello World";
	}
}
class Weixin implements IReceiver{
	@Override
	public String getInfo() {
		return "微信内容：Hello World";
	}
}
class QQ implements IReceiver{
	@Override
	public String getInfo() {
		return "QQ内容：Hello World";
	}
}
```

```java
依赖传递的三种方式和应用案例如下：
1)接口传递
//开关的接口
interface IOpenAndClose{
	public void open(ITv itv);
}

interface ITv{
	public void play();
}

//实现接口
class Impl implements IOpenAndClose{
	@Override
	public void open(ITv itv) {
		itv.play();
	}
}
//////////////////////////////////////////////////////////////////////////
2)构造方法传递
interface IOpenAndClose{
	public void open();
}

interface ITv {
	public void play();
}

class Impl implements IOpenAndClose{
	public ITv iTv;//成员
	public Impl(ITv iTv) {//构造器
		this.iTv = iTv;
	}
	@Override
	public void open() {
		this.iTv.play();
	}
}
////////////////////////////////////////////////////////////////////////   
3)setter方式传递
interface IOpenAndClose{
	public void setTv(ITv itv);
	public void open();
}

interface ITv {
	public void play();
}

class Impl implements IOpenAndClose{
	private ITv iTv;

	@Override
	public void setTv(ITv tv) {
		this.iTv = tv;
	}
	
	@Override
	public void open() {
		this.iTv.play();
	}
}
```

```
依赖倒转原则的注意事项和细节:
1)低层模块尽量都要有抽象类和接口，或者两者都有，程序稳定性更好。
2)变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序的扩展和优化。
3)继承时遵循里氏替换原则。
```



## 1.5.里氏替换原则

```
引入：
```

![原则_里氏替换原则1](设计模式_pic/原则_里氏替换原则1.jpg)

```
基本介绍：
```

![原则_里氏替换原则2](设计模式_pic/原则_里氏替换原则2.jpg)

```java
问题案例如下：
public class Demo1 {
	public static void main(String[] args) {
		A a = new A();
		System.out.println("11-3 =  "+a.fun1(11, 3));
		System.out.println("11-8 =  "+a.fun1(11, 8));
		System.out.println("==========================");
		B b = new B();
		System.out.println("11-3 =  "+b.fun1(11, 3));
		System.out.println("11-8 =  "+b.fun1(11, 8));
		System.out.println("11+3+9 = "+b.fun2(11, 3));
	}
}

class A{
	public int fun1( int a, int b ) {
		return a-b;
	}
}

class B extends A{
	@Override //重写了父类的fun1(int a, int b)
	public int fun1( int a, int b ) {
		return a+b;
	}
	
	public int fun2(int a,int b) {
		return fun1(a,b)+9;
	}
}

```

```
解决方法：
```

![原则_里氏替换原则3](设计模式_pic/原则_里氏替换原则3.jpg)

```java
public class Demo2 {
	public static void main(String[] args) {
		AA aa = new AA();
		System.out.println("11-3 =  "+aa.fun1(11, 3));
		System.out.println("11-8 =  "+aa.fun1(11, 8));
		System.out.println("==========================");
		BB bb = new BB();
		System.out.println("11-3 =  "+bb.fun1(11, 3));
		System.out.println("11-8 =  "+bb.fun1(11, 8));
		System.out.println("11-3+9 = "+bb.fun2(11, 3));
	}
}

//创建一个个国家基础的类
abstract class Base{
	public abstract int fun1(int a, int b);
}

class AA extends Base{
	@Override
	public int fun1(int a, int b) {
		return a-b;
	}
}

class BB extends Base{
	//如果B类需要使用A类的方法，使用组合关系
	private AA aa = new AA();
	
	@Override
	public int fun1(int a, int b) {
		return a+b;
	}
	
	public int fun2(int a,int b) {
		return aa.fun1(a, b)+9;
	}

}

```



## 1.6.开闭原则

```
基本介绍:
```

![原则_开闭原则1](设计模式_pic/原则_开闭原则1.jpg)

```

```

