# 					数据结构与算法  笔记

## 1. 绪论

### 1.1 什么是算法

​					算法是解决特定问题求解步骤的描述，在计算机表现为指令的有限序列，并且每条指令表示一个或多个操作。

### 1.2 算法的特征

​					输入；输出；有穷性；确定性；可行性；

#### 1.2.1 输入

​					算法具有零个或多个输入。

#### 1.2.2 输出

​					算法至少有一个或多个输出。

#### 1.2.3 有穷性

​					指算法在执行有限步骤之后，自动结束。

#### 1.3.4 确定性

​					1) 算法的每一个步骤都具有确定的含义，不会出现二义性。             					2) 算法在一定的条件下，只有一条执行路径，相同的输入只能有						唯一的输出结果。                                                                            					3) 算法的每个步骤都应该被精确定义而无歧义。

#### 1.3.5 可行性

​					算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。

## 

## 2. 复杂度

### 2.1 时间复杂度

#### 2.1.1 定义

​					在进行算法分析时，语句总的执行次数T(n) 是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。

#### 2.2.2  各种阶

​					常数阶   O(1);	线性阶   O(n);    平方阶   O(n^2);	对数阶  O(log(n));	nlogn阶  O(nlog(n));	立方阶  O(n^3);	指数阶   O(2);

| 例子              | 时间复杂度 | 阶      |
| ----------------- | ---------- | ------- |
| 666               | O(1)       | 常数阶  |
| 3*n+4             | O(n)       | 线性阶  |
| 3**n^2+4**n+5     | O(n^2)     | 平方阶  |
| 3*log(n) +4       | O(logn)    | 对数阶  |
| 2*n+3*n*log(n)+14 | O(nlogn)   | nlogn阶 |
| n^3+2*n^2+4*n+6   | O(n^3)     | 立方阶  |
| 2^n               | O(2^n)     | 指数阶  |

O(1)	<	O(logn)	<	O(n)	<	O(nlogn)	<	O(n^2)	<	O(n^3)	<	O(2^n)	<	O(n!)	<	O(n^n)

#### 2.2.3最坏情况与评价情况

### 2.2 空间复杂度

#### 2.2.1 定义

​					算法的空间复杂度通过计算算法所需的存储空间实现，算法的空间复杂度的计算公式记作: S(n) = O(f(n)) ,其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。

## 

## 3.线性表

### 3.1 定义

​					由零个或多个数据元素组成的有限序列。

​					1)首先它是一个序列，也就是说元素之间是有先来后到的

​					2)若元素纯在多个，则第一个元素无前驱，而最后一个元素无后继，其他元素都有且只有一个前驱和后继。

​					3)另外，线性表强调元素的个数是有限的。

### 3.2 顺序存储结构

#### 3.2.1 定义

​					线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。

#### 3.3.2 属性

​					1) 存储空间的起始位置

​					2) 线性表的最大存储容量

​					3) 线性表的当前长度

​				注意：数组的长度与线性表的当前长度需要区分以下：数组的长度是存放线性表的存储空间的总长度，一般初始化后不变。而线性表的当前长度是线性表中元素的个数，是会变化的。

#### 3.3.3 地址计算方法

​					假设e占用的是c个存储单元，那么对于第i个元素ai的存储位置可以由第一个元素a0推算得出:

​					Loc(ai) = Loc(a0) + (i - 1)*c ;

所以，对于线性表中任意一个元素的位置，计算它的地址都是相同的时间，时间存储性能为 O(1) ,我们通常称为随机存储结构。

#### 3.3.4 插入操作

​					- 如果插入位置不合理，抛出异常；

​					- 如果线性表长度大于等于数组长度，则抛出异常或动态增加数组容量；

​					- 从最后一个元素开始向前遍历到第 i 个位置，分别将它们都向后移动一个位置；

​					- 将要插入的元素填入位置 i 处；

​					- 线性表长度 +1 ;

#### 3.3.5 删除操作

​					- 如果删除位置不合理。抛出异常；

​					- 取出要删除的那个元素；

​					- 从删除元素位置开始遍历到最后一个元素，分别将它们都向前移动一个位置;

​					- 表长 - 1 ；

#### 3.3.6 插入和删除的时间复杂度

​					最好的情况: 插入和删除操作刚好在线性表的最后一个位置，因此不需要移动任何元素，所以此时的时间复杂度为 O(1) 。

​					最坏的情况: 差人和删除的位置是第一个元素，那就意味着要移动所有元素向前或向后，所以此时的时间复杂度为 O(n) 。

​					按概率统计计算得到平均情况的时间复杂度为 O( (n-1)/2 )。

​					所以，平均时间复杂度简化后还是 O(n) 。

#### 3.3.7 顺序存储结构的优缺点

​					线性表的舒徐存储结构，在存，读数据时，不管在哪个位置，时间复杂度都是 O(1) 。而在插入或删除时，时间复杂度都是 O(n)。

​					比较适合元素个数比较稳定，不经常插入和删除元素，而更多的操作是存取数据的应用。

​					1）优点:

​						   无须为表示表中元素之间的逻辑关系而增加额外的存储空间；

​						   可以快速地存取表中任意位置的元素；

​					2）缺点:

​							插入和删除造作需要移动大量元素；

​							当线性表长度变化较大时，难以确定存储空间的容量;

​							容易造成存储空间的“碎片”。



### 3.3 链式存储结构

#### 3.3.1 定义

​					链式存储结构的特点是用一组任意的存储单元存储线性表中的数据元素，这组存储单元可以存在内存中未被占用的任意位置。

​					把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称为指针或链。这两部分信息组成数据元素称为存储映像，称为结点( Node ) 。

​					如果链表的每个节点只包含一个指针域，就称此链表为 单链表。

​					把链表中的第一个节点的存储位置叫做头指针  ，最后一个节点的指针为空(null)。

#### 3.3.2 头指针

​					1) 头指针是指链表指向第一个节点的指针，若链表有头节点，则是指向头节点的指针。

​					2) 头指针具有标识作用，所以常用头指针冠以链表的名字(指针变量的名字)。

​					3) 无论链表是否为空，头指针均不为空。

​					4) 头指针是链表的必要元素。

#### 3.3.3 头节点

​					1) 头节点是为了操作的统一和方便而设立的，放在第一个元素的节点之前，其数据域一般无意义(但也可以用来存放链表的长度)。

​					2) 有了头节点，对在第一元素节点前插入节点和删除第一节点起操作与其他节点的操作就统一了。

​					3) 头节点不一定是链表的必须要素。



单链表图例（如下图所示）:

![单链表](数据结构与算法_pic/单链表.png)



空链表图例（如下图所示）：

![空链表](数据结构与算法_pic/空链表.png)



#### 3.3.4 单链表的读取

​				获得链表第i个数据的算法思路：

​				-声明一个结点p指向链表的第一个结点，初始化j从1开始；	

​				-当j<i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j+1;

​				-若到链表末尾p为空，则说明第i个元素不存在；

​				-若查找成功，返回结点p的数据；

​				简而言之就是：从头开始找，找到第 i 个元素为止，时间复杂度为 O(n)。

#### 3.3.5 单链表的插入

​					单链表第 i 个数据后面插入节点的算法思路:

​					1) 声明一结点p指向链表头节点，初始化j从1开始；

​					2) 当j<1时，就遍历链表，让p的指针向后移动，不断指向下一个节点，j 累加1；

​					3) 若到链表末尾p为空，则说明第 i 个元素不存在；

​					4) 否则查找成功，在系统中生成一个空节点s;

​					5) 将数据元素e 赋值给 s -> data;

​					6) 将第 i个元素的指针域的值赋值给 新节点 s 的指针域的值  ,再将第新节点s的地址值赋值给第 i 个节点的指针域额值;

#### 3.3.6 单链表的删除

​					假设元素 a 的节点为 q ,要实现删除节点q的操作，其实就是将节点q的前继节点的指针 直接指向 节点q的后继节点即可，也就是将节点q的后继节点的地址值赋值给节点q的前继节点的指针域。

​					单链表第 i 个数据删除节点的算法思路 :

​					1) 声明节点p指向链表的第一个节点，初始化 j = 1;

​					2) 当 j<1 时，就遍历链表，让p的指针向后移动，不断指向下一个节点，j 累加 1;

​					3) 若到链表末尾p为空，则说明第i 个元素不存在；

​					4) 否则查找成功，将 欲删除的而节点 p 的后一个节点的地址值赋值给 节点 p 的前一个节点的指针域；

​					5) 将q结点(被删除的结点)中的数据赋值给e,作为返回；

​					6) 释放q结点;

#### 3.3.7 单链表 vs顺序存储结构 效率PK

​					单链表无论是插入还是删除算法，其实都是由两部分构成：

​					1）遍历查找第 i 个元素;

​					2）找到后 实现插入或删除;

​					时间复杂度为 O(n);

​					如果我们不知道第 i 个元素的指针位置，单链表数据结构在插入和删除操作上，与线性表的顺序存储结构是没有太大优势的。

​					但如果，我们希望从第 i 个位置开始，插入连续 10 个元素，对于顺序存储结构意味着，梅伊西插入都需要移动 （n-1）个位置，所以每次都是 O(n);				而单链表，我们只需在第一次时，找到第 i 个位置的指针，找到它的时间复杂度为 O(n) ,接下来的插入和删除只是通过赋值移动指针而已，接下来的每次时间复杂度都是 O(1)。

​					显然，对于插入或删除数据越频繁的操作，单链表的效率优势就越明显。

#### 3.3.8 单链表的整表创建

​					单链表不像顺序存储结构那样 数据集中，单链表的数据可以是分散在内存各个角落的，它的增长也是动态的。对于每个链表来说，它所占空间的大小和位置是不需要预先分配的，可以根据系统的情况和实际的需求即时生成。

​					创建单链表的过程是一个动态生成链表的过程，从"空表"的初始状态起，以此建立各个元素结点并逐个插入链表。

​					单链表整表创建的算法思路如下：

​					1）声明一个节点 p 和计数变量 i;

​					2）初始化一个空链表 L;

​					3）让 L 的头结点的指针指向 null ,即建立一个带头结点的单链表;

​					4）循环实现后继结点的赋值和插入；

#### 3.3.9 头插法建立单链表

​					头插法从一个空表开始，生成新结点，读取数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头上，依次直到插完所有数据。

​					简单来说，就是把新加入的元素放在表头后的第一个位置：先让新结点 的 next 指向头结点之后， 然后让表头的next指向新结点。

​					就是插队，始终让新结点插在队伍第一的位置。

#### 3.3.10 尾插法建立单链表

​					头插法建立链表虽然算法简单，但生成的链表中 结点的次序和输入的顺序相反。

​					！！！！！！！！！！！！！待补充！！！！！

#### 3.3.11 单链表的整表删除

​					1）声明结点 p 和 q ；

​					2）将单链表的第一个结点赋值给 p ,将下一个结点赋值给 q;

​					3）循环执行释放 p ，将 q 赋值给 p 的操作；

#### 3.3.12 单链表与顺序存储结构的 优缺点

​					分别从 存储分配方式，时间性能，空间性能三方面来做对比。

​				    存储分配方式:

​					1）顺序存储结构用一段连续的存储单元依次存储线性表的数据元素。

​					2）单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素。

​					时间性能：

​					1）- 查找：

​							顺序存储结构为 O(1).

​							单链表为 O(n).

​					2）- 插入和删除

​							顺序存储结构需要平均移动表长一半的元素，时间为 O(n).

​							单链表在计算出某个位置的指针后，插入和删除的时间仅为 O(1).

​					空间性能：

​					顺序存储结构需要预分配存储空间，分大了，容易造成空间浪费，分小了，容易发生溢出。

​					单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制。

#### 3.3.13 静态链表

​					用数组描述的链表叫做静态链表，这种描述方法叫做游标实现法。

#### 3.3.14循环链表

​					定义：将单链表的终端结点的指针端由空指针改为指向头节点，就使整个单链表形成一个环，这种头尾相接的单链表成为单循环链表，简称循环链表。

#### 3.3.15 单链表面试题

​			题目：如何快速找到未知长度单链表得中间结点？

​			答案：

​			-普通方法：首先遍历一遍单链表以确定单链表的长度L。然后再次从头结点出发循环L/2次找到单链表的中间结点。算法的复杂度为：O( L+L/2 ) = O(  3L/2 )；

​			-nb方法：利用快慢指针。

​		      利用快慢指针原理：设置两个指针 *search, *mid都是指向单链表的头节点。其中 *search的移动速度是 *mid的两倍。当 *search指向末尾结点的时候，mid正好就在中间了。这也是标尺的思想。

### 3.4 循环链表

#### 3.4.1定义

​				对于单链表，由于每个结点只存储了向后的指针，到了尾部标识就停止了向后链接的操作。按照这样的方式，只能索引后继结点而不能索引前驱结点。

​				这样会带来一个问题：如果不从头结点出发，就无法访问到全部结点。

​				所以就有了循环链表：

​						将单链表终端结点的指针由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。如下图所示：



![循环链表](数据结构与算法_pic/循环链表.png)



#### 3.4.2约瑟夫环问题

#### 3.4.3魔术师发牌问题

### 3.5双向链表

​				比单链表多了前驱结点，如下图所示：

![双向链表](数据结构与算法_pic/双向链表.png)



#### 3.5.1双向链表的插入

![双向链表的插入](数据结构与算法_pic/双向链表的插入.png)

![双向链表的插入步骤](数据结构与算法_pic/双向链表的插入步骤.png)



#### 3.5.2双向链表的删除

![双向链表删除](数据结构与算法_pic/双向链表删除.png)

![双向链表删除步骤](数据结构与算法_pic/双向链表删除步骤.png)



## 4.栈和队列

### 4.1栈

#### 4.1.1定义

​				栈（stack）是一个后进先出（Last in first out,简称LIFO）的线性表，它要求只在表尾进行删除和插入操作。

​				所谓的栈，其实也就是一个特殊的线性表,但是它在操作上有一些特殊的要求和限制：

​					-栈的元素必须 “先进后出”；

​					-栈的操作只能在这个线性表的表尾进行；

​					-对于栈来说，这个表尾称为栈的栈顶（top）,相应的表头称为栈底（bottom）。

#### 4.1.2栈的插入和删除

​				-栈的插入操作（push）叫做进栈，也称为压栈，入栈。类似于子弹压入弹夹的动作；

​				-栈的删除操作（pop）叫做出栈，也称为弹栈。如同子弹从弹夹中出来；

#### 4.1.3栈的顺序存储结构

​				因为栈的本质是一个线性表，线性表有两种存储形式，那么栈也有分为栈的顺序存储结构个栈的链式存储结构。

​				最开始的栈中不含任何数据，叫做空栈，此时栈顶就是栈底。然后数据从栈顶进入，栈顶栈底分离，整个栈的当前容量变大。数据出栈时从栈顶弹出，栈顶狭义，整个栈的当前容量变小。

![栈](数据结构与算法_pic/栈.png)

这里定义了一个顺序存储的栈，它包含三个元素：base, top, stackSize。

其中base是指向栈底的指针变量，top是指向栈顶的指针变量，stackSize指示栈的当前可使用的最大容量。



创建一个栈,如下图所示：

![创建栈](数据结构与算法_pic/创建栈.png)



#### 4.1.4入栈操作

​				-入栈操作又称压栈操作，就是向栈中存放数据。

​				-入栈操作要在栈顶进行，每次向栈中压入一个数据，top指针就要+1，直到栈满为止。

#### 4.1.5出栈操作

​				-出栈操作就是在栈顶取出数据，栈顶指针随之下移的操作。

​				-每当从栈内弹出一个数据，栈的当前容量就 -1。

#### 4.1.6清空一个栈

​				所谓清空一个栈，就是将栈中的元素全部作废，但栈本身的物理空间并不发生改变(不是销毁)。

​				因此我们只要将 s—>top 的内容赋值为 s—>base 即可，这样 s—>base 等于s—>top，也就表明整个栈是空的了。

#### 4.1.7销毁一个栈

​				销毁一个栈与清空一个栈不同，销毁一个栈是要释放掉该栈所占据的物理内存空间，因此不要把销毁一个栈与清空一个栈这两种操作混淆。

#### 4.1.8计算栈的当前容量

​				-计算栈的当前容量也就是计算栈中元素的个数，因此只要返回 s.top - s.base即可。

​				-注意：栈的最大容量是指该栈占据内存空间的大小，其值是 s.stackSize，它与栈的当前容量不是一个概念。

#### 4.1.9栈的链式存储结构

​				

### 4.2队列

#### 4.2.1定义

​				队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。

​				与栈相反，队列是一种先进先出（First In First Out，简称FIFO）的线性表。

​				与栈相同的是，队列也是一种重要的线性结构，实现一个队列同样需要顺序表或链表作为基础。

#### 4.2.2队列的链式存储结构

​				队列既可以用链表实现，也可以用顺序表实现。和栈相反的是，栈一般用顺序表来实现，而队列常用链表来实现，简称链队列。

![链列表](数据结构与算法_pic/链列表.png)



​				将队列指针指向链队列的头结点，而对尾指针指向终端结点。（注：头节点不是必要的，为了方便操作，加上了。）

![链列表1](数据结构与算法_pic/链列表1.png)

​				空队列时，front和rear都指向头结点。

![链列表2](数据结构与算法_pic/链列表2.png)

#### 4.2.3创建一个队列

​				创建一个队列要完成两个任务：一是在内存中创建一个头结点，二是将队列的头指针和尾指针都指向这个生成的头结点，因为此时是空队列。

![创建队列](数据结构与算法_pic/创建队列.png)				

#### 4.2.4入队列

![入队列](数据结构与算法_pic/入队列.png)



![入队列code](数据结构与算法_pic/入队列code.png)



#### 4.2.5出队列

![出队列](数据结构与算法_pic/出队列.png)



![出队列2](数据结构与算法_pic/出队列2.png)



![出队列code](数据结构与算法_pic/出队列code.png)



#### 4.2.6销毁队列

![销毁队列](数据结构与算法_pic/销毁队列.png)



#### 4.2.7队列的顺序存储结构

![队列顺序存储](数据结构与算法_pic/队列顺序存储.png)



![队列顺序存储2](数据结构与算法_pic/队列顺序存储2.png)



![队列顺序存储3](数据结构与算法_pic/队列顺序存储3.png)



![循环队列定义](数据结构与算法_pic/循环队列定义.png)



![循环队列2](数据结构与算法_pic/循环队列2.png)



![循环队列定义code](数据结构与算法_pic/循环队列定义code.png)



![循环队列初始化code](数据结构与算法_pic/循环队列初始化code.png)



![循环队列入队列](数据结构与算法_pic/循环队列入队列.png)



![循环队列出队列](数据结构与算法_pic/循环队列出队列.png)



### 4.3递归

#### 4.3.1引入

​				汉诺塔问题；

​				八皇后问题；

#### 4.3.2定义

​				方法自己调用自己，满足一定条件（递归出口）后结束。



## 5.串

### 5.1定义

​				串（String）是由零个或多个字符串组成的有限序列，又名字符串。

### 5.2字符串的存储结构

​				字符串的存储结构与线性表相同，也分顺序存储结构和链式存储结构。

​				-字符串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的。按照预定的大小，为每个定义的字符串变量分配一个固定长度的存储区，一般用定长数组来定义。与线性表相似，既然是固定长度的存储区，就存空间不灵活分配的问题，那么会考虑用链式存储结构。但是，字符串一般都是连在一起表述的，"断章取义"的情况并不多，所以习惯上我们通常还是会直接定义一个足够长度的存储区来存储字符串。

### 5.3BF算法

​				原名 " Brute Force "。

​				BF算法属于朴素的模式匹配算法，它的核心思想是：

![BF算法](数据结构与算法_pic/BF算法.png)				

![BF算法2](数据结构与算法_pic/BF算法2.png)



### 5.4 KMP算法

#### 5.4.1简介

![kmp算法简介,png](数据结构与算法_pic/kmp算法简介,png.png)



​				KMP算法的核心就是避免不必要的回溯。问题由模式串决定，而不是由目标串决定。

​				不太理解，待补充；

## 6.树

### 6.1定义

​				树（Tree）是n（n>=0）个结点的有限集。当n=0时成为空树，在任意一棵非空树中:

​				-有且仅有一个特定的称为根（Root）的结点；

​				-当n>1时，其余结点可分为m（m>0）个互不相交的有限集T1,T2,...Tm，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。

![树](数据结构与算法_pic/树.png)

​				注：

​					-n>0时，根结点是唯一的，不可能存在多个根结点；

​					-m>0时，子树的个数是没有限制的，但它们互相是一定不会相交的；

=======================================================================

​	结点分类：

​				上面图片中，每一个圈圈称为树的一个结点。结点拥有的子树数就称为结点的度（Degree）,树的度取树内各结点的度的最大值。

​				-度为0的结点称为叶结点（Leaf）或终端结点；

​				-度不为0的结点称为分支结点或非终端结点，除根结点外，分支结点也称为内部结点；

![树结点](数据结构与算法_pic/树结点.png)

========================================================================

结点间的关系：

​				-结点的子树的根称为结点的孩子（child）,相应的，该结点称为孩子的双亲（Parent）,同一双亲结点的孩子之间互称为兄弟（Sibling）。s

​				-结点的祖先是从根到该结点所经分支上的所有结点。

========================================================================

结点的层次：

​				-结点的层次（Level）从根开始，根为第一层，根的孩子为第二层；

​				-其双亲在同一层的结点互为堂兄弟；

​				-树中结点的最大层次称为树的深度（Depth）或高度；

![树_结点层次](数据结构与算法_pic/树_结点层次.png)



========================================================================

其他概念：

​				-如果树中的结点的各子树看成从左至右是有序的，不能互换，则称该树为有序树，否则称为无序树；

​				-森林（Forest）是m（m>=0）棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。



### 6.2树的存储结构

#### 6.2.1双亲表示法

​				双亲表示法，就是以双亲作为索引的关键词的一种存储方式。

​				假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示其双亲结点在数组中位置的元素。

​				也就是说，每个元素除了知道自己是谁外，还知道它的parent在那里。

​				做出如下定义：

![树_双亲表示法](数据结构与算法_pic/树_双亲表示法.png)



![树_双亲表示法2](数据结构与算法_pic/树_双亲表示法2.png)



​				对于双亲表示法，我们可以根据某结点的parent的指针找到它的双亲结点，所用的事件复杂度是 O(1)，索引到parent的值为-1时，表示找到了树结点的根。但是如果要知道某结点的child是什么，那只能遍历了。



#### 6.2.2孩子表示法

​				由于树中每个结点可能有多个子树，可以考虑用多重链表来实现。

#### 6.2.3双亲孩子表示法

![树_双亲孩子表示法](数据结构与算法_pic/树_双亲孩子表示法.png)



### 6.3二叉树

#### 6.3.1定义

​				二叉树（Binary Tree）是n（n>=0）个结点的有限集合，该集合或者为非空集（空二叉树），或者由一个根结点和两棵互不相交的并且分别称为根结点的左子树和右子树的二叉树组成。

#### 6.3.2二叉树特点

​				-每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。（二叉树中的结点可以没有子树或者只有一颗子树）；

​				-左子树和右子树是有顺序的，次序不能颠倒；

​				-即使树中某结点只有一棵子树，也要区分它是左子树还是右子树，下面就是完全不同的二叉树：

![二叉树_不同](数据结构与算法_pic/二叉树_不同.png)



#### 6.3.3二叉树的五种基本形态

![二叉树_五种形态](数据结构与算法_pic/二叉树_五种形态.png)



#### 6.3.4特殊的二叉树

斜树：

​		分为左斜树和右斜树。左斜树的所有结点只有左子树。右斜树的所有结点只有右子树。

![二叉树_斜树](数据结构与算法_pic/二叉树_斜树.png)

==========================================================================



满二叉树:

​			在一个二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子结点都在同一层上，那么这样的二叉树就称为满二叉树。

![二叉树_满二叉树](数据结构与算法_pic/二叉树_满二叉树.png)

满二叉树的特点：

​				-叶子结点只能出现在最下层；

​				-非叶子结点的度一定是2；

​				-在同样深度的二叉树中，满二叉树的结点个数一定最多，同时也足也是最多;

​				-深度为k的满二叉树的结点数 一定是 2^k -1 ；

​				-那么对于满二叉树可以通过节点数 n = 2^-1得到：满二叉树的深度k = log2(n+1)；

==========================================================================



完全二叉树：

​				对一颗具有n个结点的二叉树按树层序编号，如果编号为 i （1<=i<=n）的结点与同样深度的满二叉树中编号为i的结点位置完全相同，则这棵二叉树称为完全二叉树。



完全二叉树的特点：

​				-叶子结点只能出现在最下两层；

​				-最下层的叶子一定集中在左部连续位置；

​				-倒数第二层，若有叶子结点，一定都在右部连续位置；

​				-如果结点度为1，则该结点只有左 child ;

​				-同样结点的二叉树，完全二叉树的深度最小l;



注意：满二叉树一定是完全二叉树，但完全二叉树不一定是满二叉树。



#### 6.3.5二叉树的性质

性质一：

​				在二叉树的第i层上至多有 2^(i-1) 个结点（i>=1）;

性质二：

​				深度为k的二叉树至多有 2^k -1 个结点；

性质三：

​				对于任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为 n2，则n0=n2+1；

​		证明过程如下：

​			-首先我们假设度为1的结点数为n1,则二叉树T的结点总数 n=n0+n1+n2；

​			-然后我们发现连接总数总是等于 节点数-1，即（n-1），并且等于 n1+2*n2;

​			-    n-1 = n1+2*n2,  其中n= no+n1+n2;

​				所以 (no+n1+n2) -1 = n1+2*n2;

​				最后得出 n0 = n2 + 1；



性质四：

​				具有n个结点的完全二叉树的深度为 [log2n] +1     (log2n 向下取整再加1)；

​				证明如下：

​				完全二叉树的结点数的取值范围是; 2^(k-1) -1  < n <=  2^k-1；(k为深度)  。由于n是整数，所以可以写为 2^(k-1) <= n < 2^k；

​				上面不等式两边同时取对数，得到 k-1 <= log2n < k。因为k是整数，所以k=[log2n]+1。



性质五：

​				对于一棵有n个结点的完全二叉树（其深度为[log2n]+1）的结点按层序编号，对任意结点i（1<=i<=n）有以下性质：

![二叉树_性质5](数据结构与算法_pic/二叉树_性质5.png)



#### 6.3.6二叉树的存储结构

​				二叉树的寻出一般来说也是采用链式存储结构。

![二叉树_存储结构](数据结构与算法_pic/二叉树_存储结构.png)



![二叉树_存储结构code](数据结构与算法_pic/二叉树_存储结构code.png)



#### 6.3.7二叉树的遍历

​				二叉树的遍历是指从根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问依次且仅被访问依次。

![二叉树_遍历方法](数据结构与算法_pic/二叉树_遍历方法.png)



前序遍历：

​		若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。

![二叉树_前序遍历](数据结构与算法_pic/二叉树_前序遍历.png)



中序遍历：

​		若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。

![二叉树_中序遍历](数据结构与算法_pic/二叉树_中序遍历.png)



后序遍历：

​		若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后访问根结点。

![二叉树_后序遍历](数据结构与算法_pic/二叉树_后序遍历.png)



层序遍历：

​		若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，从左至右对结点逐个访问。

![二叉树_层序遍历](数据结构与算法_pic/二叉树_层序遍历.png)



#### 6.3.8二叉树的建立和遍历算法

​			待补充

#### 6.3.9线索二叉树

​			待补充

#### 6.3.10树,森林,二叉树 的相互转换

![树转二叉树](数据结构与算法_pic/树转二叉树.png)



![森林转二叉树](数据结构与算法_pic/森林转二叉树.png)



![二叉树转为树or森林](数据结构与算法_pic/二叉树转为树or森林.png)



#### 6.4.11树与森林的遍历

![树与森林的遍历](数据结构与算法_pic/树与森林的遍历.png)



![树与森林的遍历2](数据结构与算法_pic/树与森林的遍历2.png)



![树与森林的遍历3](数据结构与算法_pic/树与森林的遍历3.png)



### 6.4赫夫曼树

#### 6.4.1概念

​		-结点的路径长度：从根结点到该结点的路径上的连接数。

​		-树的路径长度：树中每个叶子结点的路径长度之和。

​		-结点带权路径长度：结点的路径长度与结点权值的乘积。

​		-树的带权路径长度：WPL（Weight Path Length）是树中所有叶子结点的带权路径长度之和。



​		WPL的值越小，就说明构造出来的二叉树性能越优。

#### 6.4.2赫夫曼编码

​				待补充





## 7.图

### 7.1定义

​				图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中变的集合。

​				注意：

​					-线性表中我们把数据元素叫做元素，树中叫结点，在图中数据元素则称之为顶点（Vertex）。

​					-线性表可以没有数据元素，称为空表。树中可以没有结点，称为空树。而图结构在国内大部分的教材中强调顶点集合V 要满足有穷非空。

​					-线性表中，相邻的数据元素之间具有线性关系。树结构中，相邻两层的结点具有层次关系。而图结构中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。

### 7.2各种奇葩定义

![图_无向边](数据结构与算法_pic/图_无向边.png)



![图_有向边](数据结构与算法_pic/图_有向边.png)



![图_简单图](数据结构与算法_pic/图_简单图.png)



![图_无向完全图](数据结构与算法_pic/图_无向完全图.png)



![图_有向完全图](数据结构与算法_pic/图_有向完全图.png)



![图_稀稠](数据结构与算法_pic/图_稀稠.png)



![图_子图](数据结构与算法_pic/图_子图.png)



### 7.3顶点与边的关系

![图_顶点与边_无向图](数据结构与算法_pic/图_顶点与边_无向图.png)



![图_顶点与边_有向图](数据结构与算法_pic/图_顶点与边_有向图.png)



![图_无向图_路径](数据结构与算法_pic/图_无向图_路径.png)



![图_有向图_路径](数据结构与算法_pic/图_有向图_路径.png)



![图_回路](数据结构与算法_pic/图_回路.png)



![图_连通图](数据结构与算法_pic/图_连通图.png)



![图_连通分量_无向图](数据结构与算法_pic/图_连通分量_无向图.png)



![图_连通_有向图](数据结构与算法_pic/图_连通_有向图.png)



![图_图生成树](数据结构与算法_pic/图_图生成树.png)



![图_有向树](数据结构与算法_pic/图_有向树.png)



### 7.4图的存储结构

#### 7.4.1邻接矩阵

![图_邻接矩阵_无向图](数据结构与算法_pic/图_邻接矩阵_无向图.png)



![图_邻接矩阵_无向图2](数据结构与算法_pic/图_邻接矩阵_无向图2.png)



![图_邻接矩阵_无向图3](数据结构与算法_pic/图_邻接矩阵_无向图3.png)



![图_邻接矩阵_有向图](数据结构与算法_pic/图_邻接矩阵_有向图.png)



![图_邻接矩阵_有向图2](数据结构与算法_pic/图_邻接矩阵_有向图2.png)



![图_邻接矩阵_（网）](数据结构与算法_pic/图_邻接矩阵_（网）.png)



#### 7.4.2邻接表

![邻接表1](数据结构与算法_pic/邻接表1.png)

![邻接表_无向图](数据结构与算法_pic/邻接表_无向图.png)

![邻接表_无向图2](数据结构与算法_pic/邻接表_无向图2.png)

![邻接表_有向图1](数据结构与算法_pic/邻接表_有向图1.png)

![邻接表_有向图2](数据结构与算法_pic/邻接表_有向图2.png)

![邻接表(网)](数据结构与算法_pic/邻接表(网).png)



#### 7.4.3十字链表

![十字链表1](数据结构与算法_pic/十字链表1.png)

![十字链表2](数据结构与算法_pic/十字链表2.png)

![十字链表优点](数据结构与算法_pic/十字链表优点.png)



#### 7.4.4邻接多重表

![邻接多重表引入](数据结构与算法_pic/邻接多重表引入.png)

![邻接多重表引入2](数据结构与算法_pic/邻接多重表引入2.png)

![邻接多重表详细1](数据结构与算法_pic/邻接多重表详细1.png)

![邻接多重表详细2](数据结构与算法_pic/邻接多重表详细2.png)



#### 7.4.5边集数组

![边集数组概念](数据结构与算法_pic/边集数组概念.png)



### 7.5图的遍历

![图的遍历_引入](数据结构与算法_pic/图的遍历_引入.png)



#### 7.5.1深度优先遍历

![图的遍历_深度优先1](数据结构与算法_pic/图的遍历_深度优先1.png)

![图的遍历_深度优先2](数据结构与算法_pic/图的遍历_深度优先2.png)



#### 7.5.2骑士周游问题

![骑士周游问题](数据结构与算法_pic/骑士周游问题.png)

![骑士周游问题2](数据结构与算法_pic/骑士周游问题2.png)

​				具体算法待补充



#### 7.5.3广度优先遍历

![图的遍历_广度优先1](数据结构与算法_pic/图的遍历_广度优先1.png)

![图的遍历_广度优先2](数据结构与算法_pic/图的遍历_广度优先2.png)

![图的遍历_广度优先3](数据结构与算法_pic/图的遍历_广度优先3.png)

​				具体算法待补充



#### 7.5.4普里姆算法

​				具体算法待补充

#### 7.5.5克鲁斯卡尔算法

![克鲁斯卡尔算法](数据结构与算法_pic/克鲁斯卡尔算法.png)

​				具体算法待补充



#### 7.5.6最短路径

![最短路径_概述](数据结构与算法_pic/最短路径_概述.png)



#### 7.5.7迪杰斯特拉算法

​				具体算法待补充

#### 7.5.8弗洛伊德算法

​				具体算法待补充

#### 7.5.9拓扑排序

![拓扑排序1](数据结构与算法_pic/拓扑排序1.png)

![拓扑排序2](数据结构与算法_pic/拓扑排序2.png)

![拓扑排序3](数据结构与算法_pic/拓扑排序3.png)

![拓扑排序4](数据结构与算法_pic/拓扑排序4.png)



#### 7.5.10关键路径

![关键路径1](数据结构与算法_pic/关键路径1.png)

![关键路径2](数据结构与算法_pic/关键路径2.png)

​				待补充



## 8查找算法

​				静态查找：数据集合在查找的过程中，数据集合稳定，不需要添加或删除元素。

​				动态查找：数据集合在查找的过程中，需要同时添加或删除元素。

![查找结构](数据结构与算法_pic/查找结构.png)



### 8.1顺序查找

​				顺序查找又叫线性查找，是最基本的查找技术，它的查找过程是：从第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值进行比较，若某个记录的关键字和给定值相等，则查找成功。如果查找了所有的记录任然找不到与给定值相等的关键字，则查找不成功。

### 8.2插值查找

​				也称按比例查找。它是二分查找的变种，它只适用于**有序递增表**。其时间复杂度 O(log2n)。对于数据分布均匀的查找表来说，插值查找比较快。数据分布不均匀的话，不一定比二分查找快。

### 8.3斐波那契查找

​				斐波那契数列前一项与后一项的比值越来越趋近于0.618。

### 8.4线性索引查找

​				稠密索引。

​				分块索引。

​				倒排索引。

​				(了解即可)

### 8.5二叉排序树

​				重要！

​				二叉排序树（Binary Sort Tree）又称为二叉查找树，它要么是一颗空树，要么是具有下列性质的二叉树：

​				-若它的左子树不为空，则左子树上所有结点的值都小于它的根结点的值；

​				-若它的右子树不为空，则右子树上所有结点的值都大于它的根结点的值；

​				-它的左右子树分别也为二叉排序树；

#### 8.5.1二叉排序树查找

​				中序遍历一个二叉排序树，就得到一个从小到大的序列。

​				在一个二叉排序树中查找某个值，代码如下：

```java
public boolean SearchBST(BinaryTreeNode root, int key) {
    if(root == null) {
        return false;
    }
    else if(key == root.data) {
        return true;
    }
    else if(key < root.data) {
        return this.SearchBST(root.left, key);
    }
    else {
        return this.SearchBST(root.right, key);
    }
}
```

#### 8.5.2二叉排序树插入

```java
public boolean InsertBST2(BinaryTreeNode root, int key) {
    if(!this.SearchBST2(root, this.parent, key)) {
        BinaryTreeNode keyNode = new BinaryTreeNode(key, null, null);
        if(this.parent == null) {
            root = keyNode;
        }
        else if(key < this.parent.data) {
            this.parent.left = keyNode;
        }
        else this.parent.left = keyNode;
        return true;
    }
    else {
        System.out.println("the key existence in BinaryTree");
        return false;
    }
}
```

#### 8.5.3二叉排序树删除

​				分以下几种情况：

​				1.当待删除的结点为叶结点时，直接删除。

​				2.当待删除的结点仅有左子树或仅有右子树时，那就是把该节点删除后，把被删除结点的左子树或右子树放到原来被删除结点的位置即可。

​				3.当待删除的结点既有左子树又有右子树时，

​						-找到待删除结点的前驱结点，并用s指向其前驱结点；

​						-找到待删除结点的前驱结点的父节点，并用q指向前驱结点的父节点；

​						-将x的前驱结点的值赋值给x;

​						-最后修改q的指向为s的子结点，并删除s；

​						代码如下:

```java
public boolean delete(BinaryTreeNode root) {
    BinaryTreeNode q, s;
    if(root.right == null) {
        root = root.left;	
    }
    else if(root.left == null) {
        root = root.right;
    }
    else {
        q = root;
        s = root.left;
        while(s.right != null) {
            q = s;
            s = s.right;
        }
        root.data = s.data;
        if(q != root) {
            q.right = s.left;
        }
        else {
            q.left = s.left;
        }
    }	
    return true;
}
```



### 8.6平衡二叉排序树

​				首先得是一颗二叉排序树，要么它是一颗空树，要么它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。

​				我们将二叉树上的左树深度减去右树深度的值称为平衡因子BF（Balance Factor）,平衡二叉树就是一棵二叉树上的所有结点的平衡因子的绝对值小于等于1的树。

​				

​				平衡二叉树构建的基本思想就是在构建二叉排序树的过程中，每当插入一个节点时，先检查是否因插入而破坏了树的平衡性，若是，找出最小不平衡树。在保持二叉排序树特性的前提下，调整最小不平衡子树中各节点之间的链接关系，进行相应的旋转，使之成为新的平衡子树。



​				！！！！四种旋转方式，详见百度。



### 8.7多路查找树

​				多路查找树的特点是其每一个结点的孩子数可以多余两个，且每一个结点处可存储多个元素。

​				所有元素之间存在某种特定的排序关系。



### 8.8 2-3树				

​				多路查找树中的每一个结点都具有两个或三个孩子就称之为2-3树。

​				一个结点拥有两个孩子和一个元素我们称之为2结点，它和二叉排序树类似，左子树包含的元素小于结点的元素，右子树包含的元素大于结点的元素。但与二叉排序树不同的是，这个2结点要么没有孩子，要么就应该有两个孩子，不能只有一个孩子。

​				3结点与2结点类似，一个3结点有两个元素和三个孩子。

​				2-3树所有叶节点都在同一层级。

#### ====================================================



2-3树的插入：

​						比较复杂，详见百度。



2-3树的删除：

​						比较复杂，详见百度。



### 8.9 2-3-4树

​				要么是2结点，要么是3结点，要么是4结点



### 8.10 B树

​				B树（B-tree）是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例。

​				我们把结点最大的孩子树数目称为B树的阶（order），因此，2-3树是3阶B树，2-3-4树是4阶B树。



​				一个m阶B树具有如下属性：

​				-如果根结点不是叶结点，则其至少有两棵子树；

​				-每一个非根的分支结点都有（k-1）个元素和k个孩子，其中k满足: [m/2] <= k <= m；

​				-所有叶子结点都位于同一层次；

​				-每一个分支结点包含下列信息数据：

​							n（这个结点的元素个数），A0，K1，A1，K2，A2，K3，...

​							其中K为元素，且 Ki < Ki+1，Ai为指向子树根节点的指针。



### 8.11散列(哈希表)查找

​				散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置（key）。

​				我们把这种对应关系f称为散列函数，又称为哈希（Hash）函数。采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash Table）。

​				当存储记录时，通过散列函数计算出该记录的散列地址；

​				当查找记录时，我们同样通过散列函数计算该记录的散列地址，并按此散列地址访问该记录；

#### 8.11.1散列函数

​				散列函数的要求：

​					-计算简单！

​					-分布均匀！

​				常见的有以下几种方法：

==========================================================================

1.直接定值法:

​				我们可以取关键字的某个线性函数值为散列地址，即：f(key) = a*key + b	；



==========================================================================

2.数字分析法：

![散列查找_散列函数_数字分析法](数据结构与算法_pic/散列查找_散列函数_数字分析法.png)



==========================================================================

3.平方取中法:

![散列查找_散列函数_平方取中法](数据结构与算法_pic/散列查找_散列函数_平方取中法.png)



==========================================================================

4.折叠法

![散列查找_散列函数_折叠法](数据结构与算法_pic/散列查找_散列函数_折叠法.png)



==========================================================================

5.除留余数法

![散列查找_散列函数_除留余数法](数据结构与算法_pic/散列查找_散列函数_除留余数法.png)



==========================================================================

6.随机数法

![散列查找_散列函数_随机数法](数据结构与算法_pic/散列查找_散列函数_随机数法.png)



==========================================================================



视不同的情况采用不同的散列函数。

现实中，我们应该视不同的情况采用不同的散列函数，以下是散列函数的参考指标:

​	-计算散列地址所需的时间；

​	-关键字的长度；

​	-散列表的大小；

​	-关键字的分布情况；

​	-记录查找的频率；



#### 8.11.2散列冲突

​				如果两条记录计算出的散列值相同，就出现了散列冲突。如何解决散列冲突，常见的有以下几种方法：



==========================================================================

1.开放定址法：

![散列查找_散列冲突_开放定址法](数据结构与算法_pic/散列查找_散列冲突_开放定址法.png)

![散列查找_散列冲突_开放定址法2](数据结构与算法_pic/散列查找_散列冲突_开放定址法2.png)



==========================================================================

2.再散列函数法:

​				发生冲突后，换一个散列函数计算散列值。

==========================================================================

3.链地址法:

​				发生散列冲突后，将对应数据链接到该散列值映射的上一个值之后，即将散列值相同的元素放到相同槽位对应的链表中。链地址法即使在散列冲突很多的情况下，也可以保证将所有数据存储到散列表中，但是也引入了遍历单链表带来性能损耗。



==========================================================================

4.公共溢出区法：

​				将哈希表分为**基本表**和**溢出表**两部分，凡是和基本表发生冲突的元素，一律填入溢出表。

![散列查找_散列冲突_公共溢出区法](数据结构与算法_pic/散列查找_散列冲突_公共溢出区法.png)



==========================================================================