

# 1.MySql语法规范

```
1.不区分大小写，但是表名，列名，关键字，建议大写;
2.每条命令最好以分号结尾;
3.注释： 单行：-- 或 #
		多行： /*   */
```



# 2.基础查询介绍

```

```

```sql
注意 + :
1.如果是两个数值型，则相加：
	select 666+1
	输出： 667
2.如果有字符型，则先将字符型转换为数字型再相加：
	select '666'+1    转换成功，输出667
	select 666+'1'	  转换成功，输出667
	select '666'+'1'  转换成功，输出667
	select 'stu'+'666', 'stu转换失败'，输出666
	select 'stu'+'class' ,都转换失败，输出0
3.null 和 任何相加,结果都是 null	
```

```
concat(value1,value2,...)
拼接用这个，全当成字符串拼接
```



# 3.条件查询

```

```

```
模糊查询 like 也不区分大小写
```

```
如果要模糊查询的关键字种包含 % 或 _ 等关键字,例如查找包含 '%hello' 或者 '_world' 的字段。
可以使用转义符 ：select * from table where columnA like '\_world'
或者使用 escape :select * from table where columnA like '$_world' escape '$'
```

```sql
between a and b
左右都是闭区间
```

```
<=> :
对于两个非null得值比较，和 = 一样。
null <=> 非null ,结果是0
null <=>   null ,结果是1
null  =    null,结果是null

<=> 与 = 唯一得区别是：
null  =  null, 结果是 null
null <=> null, 结果是1
```



# 4.排序

```
可以按别名排序
select
	columnA as nickName
	,columnB
from
	table
order by
	nickName
```



# 5.常见函数

```

```



# 6.分组函数

```

```

```
count(column), null不计入统计
count(*),不会忽略null
count(1) = count('任意字符串') = count(常量值)
```



# 7.分组查询

```

```



# 8.连接查询

```

```

```
光join没有其他关键字，默认是inner join
```



# 9.子查询

```

```



# 11.分页查询

```
limit a,b
a为起始索引，从0开始
b为条数
```



# 12.sql顺序

```
书写顺序：

select
	cloumn ...
from
	[表连接]
on
	[连接条件]
where
	[筛选条件]
gruop by
	[分组字段]
having
	[筛选结果集]
order by
	[排序字段]
limit
	[分页]
```

```
执行顺序：

from
join
on [连接条件]
where [筛选条件]
group by [分组条件]
having [筛选结果集]
select 
order by [排序字段]
limit
```



# 13.联合查询

```
语法：

查询语句1
union
查询语句2
union
查询语句3
...

```

```
注意事项：
1.union前后的列数得一致。
2.union前后的列的类型对应顺序最好一致，如果不一致也不报错。
3.union会去掉重复记录，如果不想去重就使用 union all 。
```



# 14.插入

```
插入方式1：
insert into tableName
(col1, col2, col3, ...)
values
(value1, value2, value3, ...)
```

```
注意：
1.列的个数和值的个数必须一致;
2.可以省略列，那就是默认所有列，并且列的顺序按照表中；
```

```
插入方式2：
insert into tableName
set 
	col1=val1,
	col2=val2,
	...
```

```
两种插入方式区别：
1.方式1可以插入多行，方式二不支持：
	insert into tableName
	 (val11,val12,val13)
	,(val21,val22,val23)
	,(val31,val32,val33)
	...
2.方式1支持子查询，方式二不支持
	insert into tableName
	(col1, col2, col3)
	//后面是子查询
	select a, b, c from ....
```



# 15.修改

```
update
	tableName
set 
	colName1 = newValue1
	,colName2 = newValue2
where 
	...
```



# 16.删除

```
delete from tableName
where 
	...
```

```
整表删除的两种方式：
1.delete from tableName;
2.truncate tableName;

区别：
1.truncate效率更高;
2.如果表中有自增列，整表删除后再insert,truncate之后会从1开始，而delete之后会继续自增;
3.truncate没有返回值，delete有返回值(返回删除了几行);
4.truncate删除不能回滚，delete删除能回滚;
```



# 17.DDL

```
库的管理：

创建库: create database 库名;
删除库: drop   database 库名;

```

```
表的管理：
1.创建表：
	create table 表名(
		 列名1 类型1 [约束]
		,列名2 类型2 [约束]
		...
	);
2.修改列名:
	alter table 表名
	change column
		旧列名 新列名 新数据类型;
3.修改列数据类型：
	alter table 表名
	modify column
	列名 新数据类型;
4.添加新列:
	alter table 表名
	add column
	新列名 数据类型;
5.删除列：
	alter table 表名
	drop column
	列名;
6.修改表名：
	alter table 表名 rename to 新表名;
7.删除表：
	drop table 表名;
8.复制表：
	//只复制表结构，不复制数据
	create table 表名 like 旧表名； 
	
	//复制表结构和部分数据
	create table 表名
	select ... from ... where ...
	
	//仅复制某些字段
	create table 表名
	select 字段1，字段2，..
	from 旧表名
	where 0
	
```



# 18.数据类型

```

```

```
整型:	
```

|     类型     | 字节 |               范围               |
| :----------: | :--: | :------------------------------: |
|   Tinyint    |  1   | 有符号：-128~ 127；无符号：0~255 |
|   SmallInt   |  2   |             以此类推             |
|  Mediumint   |  3   |                                  |
| Int, Integer |  4   |                                  |
|    Bigint    |  8   |                                  |

```

```

```
小数：

浮点型：
	float			4字节
	double			8字节
	
定点型:
	decimal(M,D)	M+2字节

float和double 也可以指定 (M,D)
建表时候,decimal不指定括号里的数，默认就是 decimal(10,0)
```

```

```

```
字符型:

较短的文本：
	char
	varchar

较长的文本:
	text
	
较大的二进制:
	blob
```

|  字符类型  | 最多字符数 |  范围   |
| :--------: | :--------: | :-----: |
|  char(M)   |     M      |  0~255  |
| varchar(M) |     M      | 0~65535 |

```
char和varchar区别：
1.char节省空间
2.varchar效率高
3.char可以省略数字，默认为char(1), 而varchar不能省略数字
```

```
mysql 5.0开始，中英文一样，都占一个字符
```

```

```

```
Enum类型：

```

```
Set类型:

```

```
日期型:
```

|   类型    | 字节 | 最小值 | 最大值 |
| :-------: | :--: | :----: | :----: |
|   date    |  4   |        |        |
| datetime  |  8   |        |        |
| timestamp |  4   |        |        |
|   time    |  3   |        |        |
|   year    |  1   |        |        |



# 19.约束

```
六大约束：
	1.非空约束， nut null
	2.默认值约束: default 默认值
	3.主键约束:	primary key 保证该字段的值唯一性且非空
	4.唯一约束:	unique	保证唯一性，可以为空
	5.检查约束:	check [mysql中不支持]
	6.外键约束:	foreign key
```

```
列级约束：
	六大约束语法上都可以做为列级约束,但外键约束没有效果。
	
表级约束：
	除了非空和默认，其他都支持.
```

```
主键约束 vs 唯一约束：
1.主键约束也要求非空
2.主键约束不能有null,唯一约束可以为null
3.一张表中，主键约束只能有1个，唯一约束可以有多个
```

```
外键的特点:
1.在从表上设置外键关系
2.从表的外键列的类型和主表的关联列的类型一致或兼容
3.要求主表中的关联列必须是一个key
```

```
标志列，也称自增长列

注意：
1.标志列必须是一个key
2.1个表中最多只能有1个标志列
3.标志列 只能是数值型
```



# 20.事务

```
一条或一组sql语句组成一个执行单元，这个单元要么全部执行，要么全部不执行。
```

```
事务的ACID属性：

1.原子性(Atomicity)
	原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
	
2.一致性(Consistency)
	事务必须从一个一致性状态变换到另一个一致性状态.

3.隔离性(Isolation)
	一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。
	
4.持久性(Durability)
	持久性是指一个事务一旦被提交，它对数据库的改变是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。
```

```
事务的创建：

1.隐式事务：事务没有明显的开始和结束标记.
	比如 insert, update, delete ,这样的一句sql就是一个事务
2.显示事务:具有明显的开始和结束标记
	前提：必须先设置自动提交禁用
	步骤：
		1.set autocommit = 0;
		2.start transaction;
		3.具体的sql语句;
		4.commit;或rollback;
	
```

```
事务并发问题:
对于同时运行的多个事务，当这些事务访问数据库相同的数据时，如果没有采取必要的隔离机制，就会导致各种并发问题。

-脏读：一个事务读取了另一个事务未提交的数据.

-不可重复读：事务T1读取了一条数据，紧接着T2把这条数据改变了，然后事务T1再次读取这条数据，发现两次读取不一致.

-幻读：事务T1根据查询条件condition1查出 n 条数据，紧接着事务T2插入或删除了符合condition11的几条数据，事务T1再次查询，前后两次查询出来的条数不一致.
```

```
事务隔离级别:

1.读未提交(read uncommitted):允许事务读取违背其他事务提交的变更。脏读，不可重复读，幻读会出现.

2.读已提交(read committed):只允许事务读取已经被其他事务提交的变更。可避免脏读，但不可重复读和幻读会出现。

3.可重复读(repeatable read):在一个事务内，多次读取同一个数据都一致，在这个事务结束之前，其他事务不能对该数据进行修改。避免了脏读和不可重复读，但还是可能会有幻读。

4.串行化(serializable):要求事务只能排队执行，不能并发执行.避免了所有问题，但性能最低.

oracle支持两种：读已提交和串行化，默认是读已提交。
mysql支持4种，默认是可重复读。
```

```
保存点 savepoint
```



# 21.视图

```

```

```
创建视图:
create view as 视图名
as
查询语句
```

```
视图的好处：
1.重用sql语句。
2.简化复杂sql操作。
3.保护数据，提高安全性。
```

```
修改视图:
方式1：
	create or replace view 视图名
	as
	查询语句;
方式2:
	alter view 视图名
	as
	查询语句;
```

```
删除视图：
	drop view 视图名1,视图名2,视图名3...
```

```
查看视图：
	和查看表一样
	desc 视图名;
	或者
	show create view 视图名
```

```
更新视图(增删改):
	对于简单视图更新数据，源表的数据也会更新.
	但一下类型的数据是不能更新的:
	1.视图的定义语句里包含以下关键字: 分组函数,distinct,group by,having, union,union all
	2.常量视图
	3.视图的定义语句里包含子查询
	4.视图的定义语句里包含join
	5.视图的定义语句里where子句的子查询引用了from子句中的表
```

```
视图 vs 表:

```



# 22.变量

```

```



# 23.存储过程

```

```



# 24.函数

```

```

# 

# 

# 

# 高级部分

# 25.逻辑架构

```

```



# 26.存储引擎

```

```



|        |                          MyISAM                          |                            InnoDB                            |
| :----: | :------------------------------------------------------: | :----------------------------------------------------------: |
|  外键  |                            N                             |                              Y                               |
|  事务  |                            N                             |                              Y                               |
|   锁   | 表锁，即使操作一条记录也会锁住整张表，不适合高并发的操作 |    行锁，操作时只锁某一行，不对其他行影响，适合高并发操作    |
|  缓存  |                只缓存索引，不缓存真实数据                | 不仅缓存索引还缓存真实数据，对内存要求较高，而内存大小对性能有决定性影响 |
| 关注点 |                节约资源，消耗少，简单业务                |                    并发写，事务，更大资源                    |



# 27.索引

```

```

```
建立索引:

create index 索引名 on 表名(字段名);
```

```
哪些情况需要建立索引？

1.主键自动建立唯一索引。
2.频繁做为查询条件的字段应创建索引。
3.关联字段和外键应建立索引。
4.单/组合索引选择问题，组合索引性价比更高。
5.查询中排序的字段。
6.查询中统计或分组的字段。
```



# 28.explain

```
查看执行计划
```

```
使用explain可以模拟优化器执行SQL查询语句。
```



# 29.索引优化

```

```

```
联合索引命中条件:

1.where 条件用到的 字段 建立联合索引。

2.联合索引最强左前缀法则:以联合索引的最左边字段开始，按顺序联合后面的字段才是有效索引。
	例如: 联合索引(a,b,c,d),则有效索引还有3个，分别是(a),(a,b),(a,b,c)。

3.见了索引的字段 加上函数或者运算，索引失效。
	例如: 字段name建立索引，查询中使用 where func(name)= ... 或者 where name+3=...
	
4.范围查询右边的索引会失效
	例如: 联合索引(a,b,c)
		 查询条件是 where a=val1, b>val2, c=val3
		 那么 a和b用到了索引，c还是全表扫描
		 所以对于 有范围条件的字段应放在最右。索引(a,c,b)有效,三个字段都能命中。

5. != , <> , is not null 会导致索引失效.

6.模糊查询左模糊会导致索引失效
	例如 like '%...' 会失效, 但是 like '...%' 不失效.
	
7.字符型字段的判断条件的值不加引号会索引失效,
	例如字段 name 类型是 varchar(20),查询语句里 where name = 123,会导致索引失效，
	因为发生了类型转换，把数值 123 转换成了 字符 '123'。
	
```



# 30.关联查询优化

```

```

```
1.两表外关联，被驱动表的关联字段要建索引，驱动表的关联条件可以不建索引。
	例如 A left join B on A.id = B.id.
	那么主表A是驱动表，B是被驱动表。create index  idx_B_id on B(id) 即可. 
	
2.如果是 inner join,那么mysql会自己选择谁是被驱动表，通常将关联字段建了索引的表做为被驱动表.

3.如果两个表连接，两表各自纪录数差距较大，则应将大表做为被驱动表。

4.子查询尽量不要做为被驱动表

5.多表关联尽量直接关联，尽量避免子查询
  例如： A left join B on A.id = B.id
  		left join C on C.col = ...

6.straight_join 也是 inner join,但是它指定了左边为驱动表，右边为被驱动表;
```



# 31.子查询优化

```
尽量不要使用 not in, not exists 等。
推荐使用联合查询。
```



# 32.排序分组优化

```

```

```
排序:
1.如果排序没有顾虑条件(having,limit)，就用不上索引;

2.如果排序的字段顺序和联合索引不一致，则用不上索引;
	例如 order by a,b,c  但索引是(a,c,b)
	
3.排序的字段如果升序和降序都存在，那么用不上索引;
	例如: order by a asc , b desc
```

```
分组:
group by 使用索引的原则几乎和order by一致，唯一区别就是 group by 即使没有过滤条件用到索引，也可以直接使用索引.
```



# 33.覆盖索引

```

```



# 34.查询截取分析

```
开启慢查询日志
```



# 35.视图(高级)

```

```



# 36.数据库锁

```

```

```
上表锁:
lock table 表名1 read(或write), 表名2 read(或write) ...

表锁 解锁：
unlock tables;
```

```查询
MyISAM表锁的限制：

试验：有两个session, session1对某张表上了读锁。
1.session1可以查询该表，session2也可以查询该表;
2.session1不能查询其他没有锁定的表;
3.session1进行更新表记录操作会报错;
4.session2更新该表会等待;
5.session1释放锁之后，session2之前等待的更新操作得以执行;
简而言之，就是一个session对某张表上了读锁，这个session就只能访问这一张表，并且只能读.
其他session可以读这张表，但对这张表的写操作会被阻塞，被阻塞的来自其他线程的操作要等这张表的表锁被释放后才能执行.

试验2: 有两个session, session1对某张表上了写锁。
1.session1可以对该表进行读和写，其他session对该表的读写操作会被阻塞，直到锁被释放;

```

```
MyISAM 在执行查询语句之前，会自动给涉及的表加读锁，在执行写操作之前，会自动给涉及的表加写锁。
读锁阻塞写，写锁阻塞读写。
```

```
如何分析表锁定？
show status like 'table%'

查询出的结果中：
1.Table_locks_immediate：产生表级锁的次数，表示可以立即获取锁的查询次数，每立即获取锁，值就加一;
2.Table_locks_waited:出现表级锁定争用而发生等待的次数(不能立即获取锁的次数，每等待一次锁值加一)，此值高说明存在着较严重的表级锁争用情况;

此外，MyISAM的读写锁调度是写优先，这也是MyISAM不能做为写为主的业务的引擎的原因。因为写锁不释放，其他线程不能做任何操作，写操作会使查询很难得到锁，从而造成永久阻塞。
```

```
行锁:

对同一行纪录的写操作会被阻塞。
```

```
索引失效导致行锁变表锁:

当 更新语句的 where 条件里没有用到索引或者索引失效的时候，会进行全表扫描，行锁变成表锁.
```

```
间隙锁：

什么是间隙锁？
当我们用范围条件，而不是相等条件检索数据，并请求共享排他锁时，InnoDB会给符合条件的已有数据纪录的索引加锁，对于键值在条件范围内但并不存在的纪录，叫做间隙。
InnoDB会对这个间隙加锁，这种锁机制就是间隙锁。

危害：
当sql执行过程中通过范围查找的话，会锁定整个范围内的所有键值，即使纪录中没有一些键值。间隙锁有一个致命的弱点：就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。

```

```
如何锁定一行?

select xxx from ...   for update; 锁定某一行后，其他session的操作会被阻塞，直到锁定行的session提交了，

```

```
行锁总结:

	InnoDB存储引擎由于实现了行级锁定，行锁带来的性能损耗比表锁高，但是行锁并发处理能力比表锁高。
	
```

```
如何分析行锁定？

show status like 'innodb_row_lock%';
查询出以下参数:

1.Innodb_row_lock_current_waits:当前正在等待锁定的数量。
2.Innodb_row_lock_time:从系统等待到现在锁定总时间长度。
3.Innodb_row_lock_time_avg：每次等待所花平均时间。
4.Innodb_row_lock_time_max：从系统启动到现在等待最长一次所花的时间。
5.Innodb_row_lock_waits：系统启动后到现在总共等待的次数。

```

```
优化建议：

1.尽可能让所有数据检索都通过索引来完成，避免无索引导致行锁升级为行锁.
2.合理设计索引，尽量缩小锁的范围.
3.尽可能较少检索条件，避免间隙锁。
4.尽量控制事务大小，减少锁定资源量和锁定时间。
5.尽可能低级别事务隔离。
```



# 37.主从复制

```

```

