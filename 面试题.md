# 1.volatile

## 1.1概念

​				volatile是java虚拟机提供的轻量级同步机制。

​				三大特性：保证可见性；不保证原子性；禁止指令重排；

## 1.2JMM可见性

​				Java内存模型，Java Memory Model，简称JMM。本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。

​				由于JVM运行程序的实体是线程，每个线程创建时，JVM都会为其创建一个工作内存（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同线程间无法访问其他线程的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问过程如下图：

![JMM_内存可见性.png](面试题_pic/JMM_内存可见性.png.jpg)

​				JMM关于同步的规定：

​					1.线程解锁前，必须把共享变量的值刷新回主内存；

​					2.线程加锁前，必须读取主内存的最新值到自己的工作内存；

​					3.加锁解锁是同一把锁；

## 1.3volatile可见性

​				示例代码如下：

```java
/**
 * 1，验证volatile的可见性
 * 
 * @author Leemi
 *
 */
public class Demo1 {
	public static void main(String[] args) {
		MyData myData = new MyData();
		new Thread(() -> {
			System.out.println(Thread.currentThread().getName() + "\t come in");
			// 线程暂停一会儿
			try {
				TimeUnit.SECONDS.sleep(3);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			myData.addTo60();
			System.out.println(Thread.currentThread().getName() + "\t updated num:" + myData.num);
		}, "AAA").start();

		// 第二个线程就是我们的main线程
		while (myData.num == 0) {
			// main线程就再这里一直等待，直到num!=0
		}
		System.out.println(Thread.currentThread().getName() + "\t main mission is over, now num is :" + myData.num);

	}
}

class MyData {
	volatile int num = 0;

	public void addTo60() {
		this.num = 60;
	}
}

```

## 1.4volatile不保证原子性

​				通过前面对JMM的介绍，我们知道各个线程对主内存中的共享变量的操作都是各个线程各自拷贝到各自的工作内存进行操作后再写到主内存中的。

​				这样就存在一个问题：

​				如果一个线程AAA修改了共享变量x的值但还未写入到主内存中时，另外一个线程BBB又对主内存中的同一个变量x进行操作，但此时AAA线程的工作内存中的共享变量x对线程BBB不可见，这种工作内存与主内存同步延迟现象造成了可见性问题。

​				首先看个volatile不保证原子性的案例，代码如下：

```java
/**
 * 2，验证volatile不保证原子性
 * @author Leemi
 *
 */
public class Demo2 {
	public static void main(String[] args) {
		MyData2 myData2 = new MyData2();
		
		for( int i=0; i<20; i++ ) {
			new Thread( ()->{
				for( int j=0; j<1000; j++ ) {
					myData2.addPP();
				}
			},String.valueOf(i) ).start();
		}
		
		//等待上面20歌线程结束后，main线程再看看num的最终值是多少
		while (Thread.activeCount() >2) {
			Thread.yield();
		}
		
		System.out.println(Thread.currentThread().getName()+"\t finally num is:"+myData2.num);
		
	}
}

class MyData2 {
	volatile int num = 0;
	public void addTo60() {
		this.num = 60;
	}	
	public void addPP() {
		this.num++;
	}
}

```

​				那么如何解决呢？可以使用juc包里面的AtomicInteger类。

​				java.util.concurrent.atomic包里面有很多保证原子性的类。